"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.api = exports.schemas = void 0;
exports.createApiClient = createApiClient;
const core_1 = require("@zodios/core");
const zod_1 = require("zod");
const SignupInput = zod_1.z
    .object({
    firstName: zod_1.z.string(),
    lastName: zod_1.z.string(),
    email: zod_1.z.string().email(),
    password: zod_1.z.string().describe("Client-side plain password (min 8 chars)."),
})
    .passthrough();
const User = zod_1.z
    .object({
    id: zod_1.z.string().uuid(),
    firstName: zod_1.z.string(),
    lastName: zod_1.z.string(),
    email: zod_1.z.string().email(),
    role: zod_1.z.string(),
    avatar: zod_1.z.string().describe("URL to user avatar").nullable(),
})
    .passthrough();
const SignUpResponse = zod_1.z
    .object({ message: zod_1.z.string(), user: User })
    .passthrough();
const ErrorResponse = zod_1.z
    .object({
    code: zod_1.z.string(),
    message: zod_1.z.string(),
    details: zod_1.z
        .array(zod_1.z
        .object({ field: zod_1.z.string(), reason: zod_1.z.string() })
        .partial()
        .passthrough())
        .describe("Array of field-level errors (optional)"),
})
    .partial()
    .passthrough();
const SigninInput = zod_1.z
    .object({
    email: zod_1.z.string().email(),
    password: zod_1.z.string().describe("Plain-text password sent over TLS"),
})
    .passthrough();
const AuthUser = zod_1.z
    .object({
    id: zod_1.z.string().uuid(),
    email: zod_1.z.string().email(),
    role: zod_1.z.string(),
})
    .passthrough();
const TokenResponse = zod_1.z
    .object({
    accessToken: zod_1.z
        .string()
        .describe("Short-lived access token (if returned in body). Prefer HttpOnly cookie for security.")
        .nullable(),
    refreshToken: zod_1.z
        .string()
        .describe("Long-lived refresh token (if returned in body). Prefer HttpOnly cookie for security.")
        .nullable(),
    expiresIn: zod_1.z.number().int().describe("Access token lifetime in seconds."),
})
    .partial()
    .passthrough();
const SignInResponse = zod_1.z
    .object({
    message: zod_1.z.string(),
    user: AuthUser,
    tokens: TokenResponse.optional(),
})
    .passthrough();
const UpdateProfileInput = zod_1.z
    .object({ firstName: zod_1.z.string(), lastName: zod_1.z.string() })
    .partial()
    .passthrough();
const WebhookTransactionStatus = zod_1.z.enum(["SUCCESS", "FAILED"]);
const DepositWebhookInput = zod_1.z
    .object({
    transactionId: zod_1.z
        .string()
        .uuid()
        .describe("Internal transaction ID generated by Kizo"),
    externalRef: zod_1.z
        .string()
        .describe("Reference ID from bank / payment provider")
        .nullish(),
    status: WebhookTransactionStatus,
})
    .passthrough();
const WebhookSuccessResponse = zod_1.z
    .object({ ok: zod_1.z.boolean() })
    .partial()
    .passthrough();
const WithdrawWebhookInput = zod_1.z
    .object({
    transactionId: zod_1.z
        .string()
        .uuid()
        .describe("Internal transaction ID generated by Kizo"),
    externalRef: zod_1.z
        .string()
        .describe("Reference ID from bank / payment provider")
        .nullish(),
    status: WebhookTransactionStatus,
})
    .passthrough();
const DepositMoneyInput = zod_1.z
    .object({
    amount: zod_1.z
        .number()
        .int()
        .describe("Amount in smallest currency unit (paise/cents)"),
    note: zod_1.z.string().nullish(),
})
    .passthrough();
const DepositResponse = zod_1.z
    .object({
    transactionId: zod_1.z.string().uuid(),
    status: zod_1.z.literal("PROCESSING"),
    bankRedirectUrl: zod_1.z
        .string()
        .describe("Redirect URL if PSP requires user action")
        .nullish(),
})
    .passthrough();
const WithdrawMoneyInput = zod_1.z
    .object({
    amount: zod_1.z
        .number()
        .int()
        .describe("Amount in smallest currency unit (paise/cents)"),
    bankAccountId: zod_1.z
        .string()
        .describe("Userâ€™s linked bank account ID")
        .nullish(),
    note: zod_1.z.string().nullish(),
})
    .passthrough();
const WithdrawResponse = zod_1.z
    .object({ transactionId: zod_1.z.string().uuid(), status: zod_1.z.literal("PROCESSING") })
    .passthrough();
const P2PTransferInput = zod_1.z
    .object({
    recipient: zod_1.z.string().email().describe("Recipient user's email"),
    amount: zod_1.z
        .number()
        .int()
        .describe("Amount in smallest currency unit (paise/cents)"),
    note: zod_1.z.string().nullish(),
})
    .passthrough();
const P2PTransferResponse = zod_1.z
    .object({ transactionId: zod_1.z.string().uuid(), status: zod_1.z.literal("SUCCESS") })
    .passthrough();
const ListTransaction = zod_1.z
    .object({
    id: zod_1.z.string().uuid(),
    referenceId: zod_1.z.string(),
    amount: zod_1.z.string().describe("Amount in smallest unit serialized as string"),
    status: zod_1.z.enum(["PROCESSING", "SUCCESS", "FAILED", "REFUNDED"]),
    type: zod_1.z.enum(["DEPOSIT", "WITHDRAWAL", "TRANSFER"]),
    description: zod_1.z.string().nullish(),
    createdAt: zod_1.z.string().datetime({ offset: true }),
})
    .passthrough();
const DetailTransaction = zod_1.z
    .object({
    id: zod_1.z.string().uuid(),
    referenceId: zod_1.z.string(),
    amount: zod_1.z.string(),
    status: zod_1.z.enum(["PROCESSING", "SUCCESS", "FAILED", "REFUNDED"]),
    type: zod_1.z.enum(["DEPOSIT", "WITHDRAWAL", "TRANSFER"]),
    description: zod_1.z.string().nullish(),
    from: User.optional(),
    to: User.optional(),
    createdAt: zod_1.z.string().datetime({ offset: true }),
    processedAt: zod_1.z.string().datetime({ offset: true }).nullish(),
})
    .passthrough();
const DashboardStats = zod_1.z
    .object({
    sent: zod_1.z.string(),
    received: zod_1.z.string(),
    thisMonth: zod_1.z.string(),
    totalCount: zod_1.z.string(),
})
    .passthrough();
const DashboardData = zod_1.z
    .object({
    balance: zod_1.z.string(),
    locked: zod_1.z.string().optional(),
    stats: DashboardStats,
    recentTransactions: zod_1.z.array(ListTransaction),
})
    .passthrough();
exports.schemas = {
    SignupInput,
    User,
    SignUpResponse,
    ErrorResponse,
    SigninInput,
    AuthUser,
    TokenResponse,
    SignInResponse,
    UpdateProfileInput,
    WebhookTransactionStatus,
    DepositWebhookInput,
    WebhookSuccessResponse,
    WithdrawWebhookInput,
    DepositMoneyInput,
    DepositResponse,
    WithdrawMoneyInput,
    WithdrawResponse,
    P2PTransferInput,
    P2PTransferResponse,
    ListTransaction,
    DetailTransaction,
    DashboardStats,
    DashboardData,
};
const endpoints = (0, core_1.makeApi)([
    {
        method: "post",
        path: "/auth/refresh",
        alias: "postAuthrefresh",
        description: `Reads the HttpOnly &#x60;refresh_token&#x60; cookie (Path&#x3D;/api/v1/auth) and, if valid, sets a new &#x60;access_token&#x60; cookie (Path&#x3D;/) in the response.
`,
        requestFormat: "json",
        response: zod_1.z.object({ message: zod_1.z.string() }).partial().passthrough(),
        errors: [
            {
                status: 401,
                description: `Refresh token missing or invalid`,
                schema: ErrorResponse,
            },
        ],
    },
    {
        method: "post",
        path: "/auth/signin",
        alias: "postAuthsignin",
        requestFormat: "json",
        parameters: [
            {
                name: "body",
                type: "Body",
                schema: SigninInput,
            },
        ],
        response: SignInResponse,
        errors: [
            {
                status: 401,
                description: `Invalid credentials`,
                schema: ErrorResponse,
            },
        ],
    },
    {
        method: "post",
        path: "/auth/signup",
        alias: "postAuthsignup",
        requestFormat: "json",
        parameters: [
            {
                name: "body",
                type: "Body",
                schema: SignupInput,
            },
        ],
        response: SignUpResponse,
        errors: [
            {
                status: 409,
                description: `User already exists`,
                schema: ErrorResponse,
            },
        ],
    },
    {
        method: "get",
        path: "/dashboard",
        alias: "getDashboard",
        requestFormat: "json",
        response: DashboardData,
        errors: [
            {
                status: 401,
                description: `Unauthorized`,
                schema: ErrorResponse,
            },
        ],
    },
    {
        method: "post",
        path: "/payment/deposit",
        alias: "postPaymentdeposit",
        requestFormat: "json",
        parameters: [
            {
                name: "body",
                type: "Body",
                schema: DepositMoneyInput,
            },
            {
                name: "Idempotency-Key",
                type: "Header",
                schema: zod_1.z
                    .string()
                    .min(8)
                    .max(255)
                    .describe("A unique key generated by the client to guarantee idempotent requests. The same key must be reused for retries of the same logical operation. Scope: per authenticated user + endpoint."),
            },
        ],
        response: DepositResponse,
    },
    {
        method: "post",
        path: "/payment/transfer",
        alias: "postPaymenttransfer",
        description: `Instantly transfers funds from the authenticated user&#x27;s wallet to another user&#x27;s wallet. This is an internal ledger operation and completes synchronously. Operation is idempotent.
`,
        requestFormat: "json",
        parameters: [
            {
                name: "body",
                type: "Body",
                schema: P2PTransferInput,
            },
            {
                name: "Idempotency-Key",
                type: "Header",
                schema: zod_1.z
                    .string()
                    .min(8)
                    .max(255)
                    .describe("A unique key generated by the client to guarantee idempotent requests. The same key must be reused for retries of the same logical operation. Scope: per authenticated user + endpoint."),
            },
        ],
        response: P2PTransferResponse,
        errors: [
            {
                status: 400,
                description: `Invalid request or insufficient balance`,
                schema: ErrorResponse,
            },
            {
                status: 401,
                description: `Unauthorized`,
                schema: zod_1.z.void(),
            },
            {
                status: 404,
                description: `Recipient not found`,
                schema: ErrorResponse,
            },
            {
                status: 500,
                description: `Internal server error`,
                schema: zod_1.z.void(),
            },
        ],
    },
    {
        method: "post",
        path: "/payment/withdraw",
        alias: "postPaymentwithdraw",
        description: `Initiates a withdrawal from the authenticated user&#x27;s wallet to a linked bank account. Funds are locked until webhook confirmation. This operation is idempotent.
`,
        requestFormat: "json",
        parameters: [
            {
                name: "body",
                type: "Body",
                schema: WithdrawMoneyInput,
            },
            {
                name: "Idempotency-Key",
                type: "Header",
                schema: zod_1.z
                    .string()
                    .min(8)
                    .max(255)
                    .describe("A unique key generated by the client to guarantee idempotent requests. The same key must be reused for retries of the same logical operation. Scope: per authenticated user + endpoint."),
            },
        ],
        response: WithdrawResponse,
        errors: [
            {
                status: 400,
                description: `Invalid request or insufficient balance`,
                schema: ErrorResponse,
            },
            {
                status: 401,
                description: `Unauthorized`,
                schema: zod_1.z.void(),
            },
            {
                status: 500,
                description: `Internal server error`,
                schema: zod_1.z.void(),
            },
        ],
    },
    {
        method: "get",
        path: "/transactions",
        alias: "getTransactions",
        description: `Returns a paginated list of the authenticated user&#x27;s transactions. Supports filtering by direction and search.
`,
        requestFormat: "json",
        parameters: [
            {
                name: "type",
                type: "Query",
                schema: zod_1.z
                    .enum(["sent", "received", "pending"])
                    .describe("Filter by transaction direction")
                    .optional(),
            },
            {
                name: "search",
                type: "Query",
                schema: zod_1.z
                    .string()
                    .describe("Search by referenceId or description")
                    .optional(),
            },
            {
                name: "take",
                type: "Query",
                schema: zod_1.z
                    .number()
                    .int()
                    .describe("Number of records to return")
                    .optional()
                    .default(20),
            },
            {
                name: "skip",
                type: "Query",
                schema: zod_1.z
                    .number()
                    .int()
                    .describe("Number of records to skip")
                    .optional()
                    .default(0),
            },
        ],
        response: zod_1.z
            .object({
            transactions: zod_1.z.array(ListTransaction),
            total: zod_1.z.number().int(),
        })
            .passthrough(),
        errors: [
            {
                status: 401,
                description: `Unauthorized`,
                schema: ErrorResponse,
            },
        ],
    },
    {
        method: "get",
        path: "/transactions/:id",
        alias: "getTransactionsId",
        description: `Returns full details for a single transaction.`,
        requestFormat: "json",
        parameters: [
            {
                name: "id",
                type: "Path",
                schema: zod_1.z.string().uuid().describe("Transaction ID"),
            },
        ],
        response: DetailTransaction,
        errors: [
            {
                status: 401,
                description: `Unauthorized`,
                schema: ErrorResponse,
            },
            {
                status: 404,
                description: `Transaction not found`,
                schema: ErrorResponse,
            },
        ],
    },
    {
        method: "get",
        path: "/transactions/export",
        alias: "getTransactionsexport",
        description: `Exports the authenticated user&#x27;s transactions as a CSV file. Respects the same filters as the list endpoint.
`,
        requestFormat: "json",
        parameters: [
            {
                name: "type",
                type: "Query",
                schema: zod_1.z.enum(["sent", "received", "pending"]).optional(),
            },
            {
                name: "search",
                type: "Query",
                schema: zod_1.z.string().optional(),
            },
        ],
        response: zod_1.z.void(),
        errors: [
            {
                status: 401,
                description: `Unauthorized`,
                schema: ErrorResponse,
            },
        ],
    },
    {
        method: "post",
        path: "/user/avatar/avatar",
        alias: "postUseravataravatar",
        description: `Uploads and updates the authenticated user&#x27;s avatar. The file is processed and optimized on the server before being stored.
`,
        requestFormat: "form-data",
        parameters: [
            {
                name: "body",
                type: "Body",
                schema: zod_1.z.object({ file: zod_1.z.instanceof(File) }).passthrough(),
            },
        ],
        response: zod_1.z.object({ success: zod_1.z.boolean() }).partial().passthrough(),
        errors: [
            {
                status: 400,
                description: `Invalid file or missing file`,
                schema: zod_1.z.object({ message: zod_1.z.string() }).partial().passthrough(),
            },
            {
                status: 401,
                description: `Unauthorized`,
                schema: zod_1.z.object({ message: zod_1.z.string() }).partial().passthrough(),
            },
            {
                status: 500,
                description: `Internal server error`,
                schema: zod_1.z.object({ message: zod_1.z.string() }).partial().passthrough(),
            },
        ],
    },
    {
        method: "get",
        path: "/user/me",
        alias: "getUserme",
        description: `Reads the HttpOnly &#x60;access_token&#x60; cookie and returns the authenticated user.
`,
        requestFormat: "json",
        response: zod_1.z
            .object({ message: zod_1.z.string(), user: User })
            .partial()
            .passthrough(),
        errors: [
            {
                status: 401,
                description: `Unauthorized`,
                schema: ErrorResponse,
            },
        ],
    },
    {
        method: "patch",
        path: "/user/update-profile",
        alias: "patchUserupdateProfile",
        requestFormat: "json",
        parameters: [
            {
                name: "body",
                type: "Body",
                schema: UpdateProfileInput,
            },
        ],
        response: User,
        errors: [
            {
                status: 400,
                description: `Validation error`,
                schema: ErrorResponse,
            },
            {
                status: 401,
                description: `Unauthorized (missing/invalid token)`,
                schema: ErrorResponse,
            },
            {
                status: 403,
                description: `Forbidden (insufficient permissions)`,
                schema: ErrorResponse,
            },
        ],
    },
    {
        method: "post",
        path: "/webhooks/deposit",
        alias: "postWebhooksdeposit",
        description: `Webhook endpoint called by the bank / on-ramp provider to notify Kizo about deposit success or failure. This endpoint is idempotent and retry-safe.
`,
        requestFormat: "json",
        parameters: [
            {
                name: "body",
                type: "Body",
                schema: DepositWebhookInput,
            },
            {
                name: "Idempotency-Key",
                type: "Header",
                schema: zod_1.z
                    .string()
                    .min(8)
                    .max(255)
                    .describe("A unique key generated by the client to guarantee idempotent requests. The same key must be reused for retries of the same logical operation. Scope: per authenticated user + endpoint."),
            },
        ],
        response: zod_1.z.object({ ok: zod_1.z.boolean() }).partial().passthrough(),
        errors: [
            {
                status: 400,
                description: `Invalid payload`,
                schema: ErrorResponse,
            },
            {
                status: 500,
                description: `Webhook processing failed`,
                schema: ErrorResponse,
            },
        ],
    },
    {
        method: "post",
        path: "/webhooks/withdraw",
        alias: "postWebhookswithdraw",
        description: `Webhook endpoint called by the bank / off-ramp provider to notify Kizo about withdrawal success or failure. On success, locked funds are released. On failure, locked funds are refunded. This endpoint is idempotent and retry-safe.
`,
        requestFormat: "json",
        parameters: [
            {
                name: "body",
                type: "Body",
                schema: WithdrawWebhookInput,
            },
            {
                name: "Idempotency-Key",
                type: "Header",
                schema: zod_1.z
                    .string()
                    .min(8)
                    .max(255)
                    .describe("A unique key generated by the client to guarantee idempotent requests. The same key must be reused for retries of the same logical operation. Scope: per authenticated user + endpoint."),
            },
        ],
        response: zod_1.z.object({ ok: zod_1.z.boolean() }).partial().passthrough(),
        errors: [
            {
                status: 400,
                description: `Invalid payload`,
                schema: ErrorResponse,
            },
            {
                status: 500,
                description: `Webhook processing failed`,
                schema: ErrorResponse,
            },
        ],
    },
]);
exports.api = new core_1.Zodios(endpoints);
function createApiClient(baseUrl, options) {
    return new core_1.Zodios(baseUrl, endpoints, options);
}
