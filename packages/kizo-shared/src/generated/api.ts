import { makeApi, Zodios, type ZodiosOptions } from "@zodios/core";
import { z } from "zod";

type SignUpResponse = {
  /**
   * @example "User created successfully"
   */
  message: string;
  user: User;
};
type User = {
  /**
   * @example "9b1deb4d-0000-0000-0000-2f3a"
   */
  id: string;
  /**
   * @example "Test"
   */
  firstName: string;
  /**
   * @example "01"
   */
  lastName: string;
  /**
   * @example "Test01@example.com"
   */
  email: string;
  /**
   * @example "User"
   */
  role: string;
  /**
   * URL to user avatar
   */
  avatar: string | null;
};
type SignInResponse = {
  /**
   * @example "Login successful"
   */
  message: string;
  user: AuthUser;
  tokens?: TokenResponse | undefined;
};
type AuthUser = {
  /**
   * @example "9b1deb4d-0000-0000-0000-2f3a"
   */
  id: string;
  /**
   * @example "aman@example.com"
   */
  email: string;
  /**
   * @example "user"
   */
  role: string;
};
type TokenResponse = Partial<{
  /**
   * Short-lived access token (if returned in body). Prefer HttpOnly cookie for security.
   */
  accessToken: string | null;
  /**
   * Long-lived refresh token (if returned in body). Prefer HttpOnly cookie for security.
   */
  refreshToken: string | null;
  /**
   * Access token lifetime in seconds.
   */
  expiresIn: number;
}>;
type DepositWebhookInput = {
  /**
   * Internal transaction ID generated by Kizo
   *
   * @example "d9f0c2dd-9ac7-4354-83f5-62f0ee0dc56b"
   */
  transactionId: string;
  externalRef?:
    | /**
     * Reference ID from bank / payment provider
     *
     * @example "bank-dep-12345"
     */
    (string | null)
    | undefined;
  status: WebhookTransactionStatus;
};
type WebhookTransactionStatus =
  /**
   * @example "SUCCESS"
   * @enum SUCCESS, FAILED
   */
  "SUCCESS" | "FAILED";
type WithdrawWebhookInput = {
  /**
   * Internal transaction ID generated by Kizo
   *
   * @example "a13c4d02-21c1-4f2f-9a2e-81f9bfe6b221"
   */
  transactionId: string;
  externalRef?:
    | /**
     * Reference ID from bank / payment provider
     *
     * @example "bank-wd-67890"
     */
    (string | null)
    | undefined;
  status: WebhookTransactionStatus;
};
type DetailTransaction = {
  id: string;
  referenceId: string;
  amount: string;
  /**
   * @enum PROCESSING, SUCCESS, FAILED, REFUNDED
   */
  status: "PROCESSING" | "SUCCESS" | "FAILED" | "REFUNDED";
  /**
   * @enum DEPOSIT, WITHDRAWAL, TRANSFER
   */
  type: "DEPOSIT" | "WITHDRAWAL" | "TRANSFER";
  description?: (string | null) | undefined;
  from?: User | undefined;
  to?: User | undefined;
  createdAt: string;
  processedAt?: (string | null) | undefined;
};
type DashboardData = {
  /**
   * @example 150000
   */
  balance: string;
  locked?: /**
   * @example 150000
   */
  string | undefined;
  stats: DashboardStats;
  recentTransactions: Array<ListTransaction>;
};
type DashboardStats = {
  /**
   * @example 12000
   */
  sent: string;
  /**
   * @example 8000
   */
  received: string;
  /**
   * @example 5000
   */
  thisMonth: string;
  /**
   * @example 42
   */
  totalCount: string;
};
type ListTransaction = {
  id: string;
  /**
   * @example "tx_abc123"
   */
  referenceId: string;
  /**
   * Amount in smallest unit serialized as string
   */
  amount: string;
  /**
   * @enum PROCESSING, SUCCESS, FAILED, REFUNDED
   */
  status: "PROCESSING" | "SUCCESS" | "FAILED" | "REFUNDED";
  /**
   * @enum DEPOSIT, WITHDRAWAL, TRANSFER
   */
  type: "DEPOSIT" | "WITHDRAWAL" | "TRANSFER";
  description?: (string | null) | undefined;
  createdAt: string;
};

const SignupInput = z
  .object({
    firstName: z.string(),
    lastName: z.string(),
    email: z.string().email(),
    password: z.string().describe("Client-side plain password (min 8 chars)."),
  })
  .passthrough();
const User: z.ZodType<User> = z
  .object({
    id: z.string().uuid(),
    firstName: z.string(),
    lastName: z.string(),
    email: z.string().email(),
    role: z.string(),
    avatar: z.string().describe("URL to user avatar").nullable(),
  })
  .passthrough();
const SignUpResponse: z.ZodType<SignUpResponse> = z
  .object({ message: z.string(), user: User })
  .passthrough();
const ErrorResponse = z
  .object({
    code: z.string(),
    message: z.string(),
    details: z
      .array(
        z
          .object({ field: z.string(), reason: z.string() })
          .partial()
          .passthrough()
      )
      .describe("Array of field-level errors (optional)"),
  })
  .partial()
  .passthrough();
const SigninInput = z
  .object({
    email: z.string().email(),
    password: z.string().describe("Plain-text password sent over TLS"),
  })
  .passthrough();
const AuthUser: z.ZodType<AuthUser> = z
  .object({
    id: z.string().uuid(),
    email: z.string().email(),
    role: z.string(),
  })
  .passthrough();
const TokenResponse: z.ZodType<TokenResponse> = z
  .object({
    accessToken: z
      .string()
      .describe(
        "Short-lived access token (if returned in body). Prefer HttpOnly cookie for security."
      )
      .nullable(),
    refreshToken: z
      .string()
      .describe(
        "Long-lived refresh token (if returned in body). Prefer HttpOnly cookie for security."
      )
      .nullable(),
    expiresIn: z.number().int().describe("Access token lifetime in seconds."),
  })
  .partial()
  .passthrough();
const SignInResponse: z.ZodType<SignInResponse> = z
  .object({
    message: z.string(),
    user: AuthUser,
    tokens: TokenResponse.optional(),
  })
  .passthrough();
const UpdateProfileInput = z
  .object({ firstName: z.string(), lastName: z.string() })
  .partial()
  .passthrough();
const WebhookTransactionStatus = z.enum(["SUCCESS", "FAILED"]);
const DepositWebhookInput: z.ZodType<DepositWebhookInput> = z
  .object({
    transactionId: z
      .string()
      .uuid()
      .describe("Internal transaction ID generated by Kizo"),
    externalRef: z
      .string()
      .describe("Reference ID from bank / payment provider")
      .nullish(),
    status: WebhookTransactionStatus,
  })
  .passthrough();
const WebhookSuccessResponse = z
  .object({ ok: z.boolean() })
  .partial()
  .passthrough();
const WithdrawWebhookInput: z.ZodType<WithdrawWebhookInput> = z
  .object({
    transactionId: z
      .string()
      .uuid()
      .describe("Internal transaction ID generated by Kizo"),
    externalRef: z
      .string()
      .describe("Reference ID from bank / payment provider")
      .nullish(),
    status: WebhookTransactionStatus,
  })
  .passthrough();
const DepositMoneyInput = z
  .object({
    amount: z
      .number()
      .int()
      .describe("Amount in smallest currency unit (paise/cents)"),
    note: z.string().nullish(),
  })
  .passthrough();
const DepositResponse = z
  .object({
    transactionId: z.string().uuid(),
    status: z.literal("PROCESSING"),
    bankRedirectUrl: z
      .string()
      .describe("Redirect URL if PSP requires user action")
      .nullish(),
  })
  .passthrough();
const WithdrawMoneyInput = z
  .object({
    amount: z
      .number()
      .int()
      .describe("Amount in smallest currency unit (paise/cents)"),
    bankAccountId: z
      .string()
      .describe("Userâ€™s linked bank account ID")
      .nullish(),
    note: z.string().nullish(),
  })
  .passthrough();
const WithdrawResponse = z
  .object({ transactionId: z.string().uuid(), status: z.literal("PROCESSING") })
  .passthrough();
const P2PTransferInput = z
  .object({
    recipient: z.string().email().describe("Recipient user's email"),
    amount: z
      .number()
      .int()
      .describe("Amount in smallest currency unit (paise/cents)"),
    note: z.string().nullish(),
  })
  .passthrough();
const P2PTransferResponse = z
  .object({ transactionId: z.string().uuid(), status: z.literal("SUCCESS") })
  .passthrough();
const ListTransaction: z.ZodType<ListTransaction> = z
  .object({
    id: z.string().uuid(),
    referenceId: z.string(),
    amount: z.string().describe("Amount in smallest unit serialized as string"),
    status: z.enum(["PROCESSING", "SUCCESS", "FAILED", "REFUNDED"]),
    type: z.enum(["DEPOSIT", "WITHDRAWAL", "TRANSFER"]),
    description: z.string().nullish(),
    createdAt: z.string().datetime({ offset: true }),
  })
  .passthrough();
const DetailTransaction: z.ZodType<DetailTransaction> = z
  .object({
    id: z.string().uuid(),
    referenceId: z.string(),
    amount: z.string(),
    status: z.enum(["PROCESSING", "SUCCESS", "FAILED", "REFUNDED"]),
    type: z.enum(["DEPOSIT", "WITHDRAWAL", "TRANSFER"]),
    description: z.string().nullish(),
    from: User.optional(),
    to: User.optional(),
    createdAt: z.string().datetime({ offset: true }),
    processedAt: z.string().datetime({ offset: true }).nullish(),
  })
  .passthrough();
const DashboardStats: z.ZodType<DashboardStats> = z
  .object({
    sent: z.string(),
    received: z.string(),
    thisMonth: z.string(),
    totalCount: z.string(),
  })
  .passthrough();
const DashboardData: z.ZodType<DashboardData> = z
  .object({
    balance: z.string(),
    locked: z.string().optional(),
    stats: DashboardStats,
    recentTransactions: z.array(ListTransaction),
  })
  .passthrough();

export const schemas = {
  SignupInput,
  User,
  SignUpResponse,
  ErrorResponse,
  SigninInput,
  AuthUser,
  TokenResponse,
  SignInResponse,
  UpdateProfileInput,
  WebhookTransactionStatus,
  DepositWebhookInput,
  WebhookSuccessResponse,
  WithdrawWebhookInput,
  DepositMoneyInput,
  DepositResponse,
  WithdrawMoneyInput,
  WithdrawResponse,
  P2PTransferInput,
  P2PTransferResponse,
  ListTransaction,
  DetailTransaction,
  DashboardStats,
  DashboardData,
};

const endpoints = makeApi([
  {
    method: "post",
    path: "/auth/refresh",
    alias: "postAuthrefresh",
    description: `Reads the HttpOnly &#x60;refresh_token&#x60; cookie (Path&#x3D;/api/v1/auth) and, if valid, sets a new &#x60;access_token&#x60; cookie (Path&#x3D;/) in the response.
`,
    requestFormat: "json",
    response: z.object({ message: z.string() }).partial().passthrough(),
    errors: [
      {
        status: 401,
        description: `Refresh token missing or invalid`,
        schema: ErrorResponse,
      },
    ],
  },
  {
    method: "post",
    path: "/auth/signin",
    alias: "postAuthsignin",
    requestFormat: "json",
    parameters: [
      {
        name: "body",
        type: "Body",
        schema: SigninInput,
      },
    ],
    response: SignInResponse,
    errors: [
      {
        status: 401,
        description: `Invalid credentials`,
        schema: ErrorResponse,
      },
    ],
  },
  {
    method: "post",
    path: "/auth/signup",
    alias: "postAuthsignup",
    requestFormat: "json",
    parameters: [
      {
        name: "body",
        type: "Body",
        schema: SignupInput,
      },
    ],
    response: SignUpResponse,
    errors: [
      {
        status: 409,
        description: `User already exists`,
        schema: ErrorResponse,
      },
    ],
  },
  {
    method: "get",
    path: "/dashboard",
    alias: "getDashboard",
    requestFormat: "json",
    response: DashboardData,
    errors: [
      {
        status: 401,
        description: `Unauthorized`,
        schema: ErrorResponse,
      },
    ],
  },
  {
    method: "post",
    path: "/payment/deposit",
    alias: "postPaymentdeposit",
    requestFormat: "json",
    parameters: [
      {
        name: "body",
        type: "Body",
        schema: DepositMoneyInput,
      },
      {
        name: "Idempotency-Key",
        type: "Header",
        schema: z
          .string()
          .min(8)
          .max(255)
          .describe(
            "A unique key generated by the client to guarantee idempotent requests. The same key must be reused for retries of the same logical operation. Scope: per authenticated user + endpoint."
          ),
      },
    ],
    response: DepositResponse,
  },
  {
    method: "post",
    path: "/payment/transfer",
    alias: "postPaymenttransfer",
    description: `Instantly transfers funds from the authenticated user&#x27;s wallet to another user&#x27;s wallet. This is an internal ledger operation and completes synchronously. Operation is idempotent.
`,
    requestFormat: "json",
    parameters: [
      {
        name: "body",
        type: "Body",
        schema: P2PTransferInput,
      },
      {
        name: "Idempotency-Key",
        type: "Header",
        schema: z
          .string()
          .min(8)
          .max(255)
          .describe(
            "A unique key generated by the client to guarantee idempotent requests. The same key must be reused for retries of the same logical operation. Scope: per authenticated user + endpoint."
          ),
      },
    ],
    response: P2PTransferResponse,
    errors: [
      {
        status: 400,
        description: `Invalid request or insufficient balance`,
        schema: ErrorResponse,
      },
      {
        status: 401,
        description: `Unauthorized`,
        schema: z.void(),
      },
      {
        status: 404,
        description: `Recipient not found`,
        schema: ErrorResponse,
      },
      {
        status: 500,
        description: `Internal server error`,
        schema: z.void(),
      },
    ],
  },
  {
    method: "post",
    path: "/payment/withdraw",
    alias: "postPaymentwithdraw",
    description: `Initiates a withdrawal from the authenticated user&#x27;s wallet to a linked bank account. Funds are locked until webhook confirmation. This operation is idempotent.
`,
    requestFormat: "json",
    parameters: [
      {
        name: "body",
        type: "Body",
        schema: WithdrawMoneyInput,
      },
      {
        name: "Idempotency-Key",
        type: "Header",
        schema: z
          .string()
          .min(8)
          .max(255)
          .describe(
            "A unique key generated by the client to guarantee idempotent requests. The same key must be reused for retries of the same logical operation. Scope: per authenticated user + endpoint."
          ),
      },
    ],
    response: WithdrawResponse,
    errors: [
      {
        status: 400,
        description: `Invalid request or insufficient balance`,
        schema: ErrorResponse,
      },
      {
        status: 401,
        description: `Unauthorized`,
        schema: z.void(),
      },
      {
        status: 500,
        description: `Internal server error`,
        schema: z.void(),
      },
    ],
  },
  {
    method: "get",
    path: "/transactions",
    alias: "getTransactions",
    description: `Returns a paginated list of the authenticated user&#x27;s transactions. Supports filtering by direction and search.
`,
    requestFormat: "json",
    parameters: [
      {
        name: "type",
        type: "Query",
        schema: z
          .enum(["sent", "received", "pending"])
          .describe("Filter by transaction direction")
          .optional(),
      },
      {
        name: "search",
        type: "Query",
        schema: z
          .string()
          .describe("Search by referenceId or description")
          .optional(),
      },
      {
        name: "take",
        type: "Query",
        schema: z
          .number()
          .int()
          .describe("Number of records to return")
          .optional()
          .default(20),
      },
      {
        name: "skip",
        type: "Query",
        schema: z
          .number()
          .int()
          .describe("Number of records to skip")
          .optional()
          .default(0),
      },
    ],
    response: z
      .object({
        transactions: z.array(ListTransaction),
        total: z.number().int(),
      })
      .passthrough(),
    errors: [
      {
        status: 401,
        description: `Unauthorized`,
        schema: ErrorResponse,
      },
    ],
  },
  {
    method: "get",
    path: "/transactions/:id",
    alias: "getTransactionsId",
    description: `Returns full details for a single transaction.`,
    requestFormat: "json",
    parameters: [
      {
        name: "id",
        type: "Path",
        schema: z.string().uuid().describe("Transaction ID"),
      },
    ],
    response: DetailTransaction,
    errors: [
      {
        status: 401,
        description: `Unauthorized`,
        schema: ErrorResponse,
      },
      {
        status: 404,
        description: `Transaction not found`,
        schema: ErrorResponse,
      },
    ],
  },
  {
    method: "get",
    path: "/transactions/export",
    alias: "getTransactionsexport",
    description: `Exports the authenticated user&#x27;s transactions as a CSV file. Respects the same filters as the list endpoint.
`,
    requestFormat: "json",
    parameters: [
      {
        name: "type",
        type: "Query",
        schema: z.enum(["sent", "received", "pending"]).optional(),
      },
      {
        name: "search",
        type: "Query",
        schema: z.string().optional(),
      },
    ],
    response: z.void(),
    errors: [
      {
        status: 401,
        description: `Unauthorized`,
        schema: ErrorResponse,
      },
    ],
  },
  {
    method: "post",
    path: "/user/avatar/avatar",
    alias: "postUseravataravatar",
    description: `Uploads and updates the authenticated user&#x27;s avatar. The file is processed and optimized on the server before being stored.
`,
    requestFormat: "form-data",
    parameters: [
      {
        name: "body",
        type: "Body",
        schema: z.object({ file: z.instanceof(File) }).passthrough(),
      },
    ],
    response: z.object({ success: z.boolean() }).partial().passthrough(),
    errors: [
      {
        status: 400,
        description: `Invalid file or missing file`,
        schema: z.object({ message: z.string() }).partial().passthrough(),
      },
      {
        status: 401,
        description: `Unauthorized`,
        schema: z.object({ message: z.string() }).partial().passthrough(),
      },
      {
        status: 500,
        description: `Internal server error`,
        schema: z.object({ message: z.string() }).partial().passthrough(),
      },
    ],
  },
  {
    method: "get",
    path: "/user/me",
    alias: "getUserme",
    description: `Reads the HttpOnly &#x60;access_token&#x60; cookie and returns the authenticated user.
`,
    requestFormat: "json",
    response: z
      .object({ message: z.string(), user: User })
      .partial()
      .passthrough(),
    errors: [
      {
        status: 401,
        description: `Unauthorized`,
        schema: ErrorResponse,
      },
    ],
  },
  {
    method: "patch",
    path: "/user/update-profile",
    alias: "patchUserupdateProfile",
    requestFormat: "json",
    parameters: [
      {
        name: "body",
        type: "Body",
        schema: UpdateProfileInput,
      },
    ],
    response: User,
    errors: [
      {
        status: 400,
        description: `Validation error`,
        schema: ErrorResponse,
      },
      {
        status: 401,
        description: `Unauthorized (missing/invalid token)`,
        schema: ErrorResponse,
      },
      {
        status: 403,
        description: `Forbidden (insufficient permissions)`,
        schema: ErrorResponse,
      },
    ],
  },
  {
    method: "post",
    path: "/webhooks/deposit",
    alias: "postWebhooksdeposit",
    description: `Webhook endpoint called by the bank / on-ramp provider to notify Kizo about deposit success or failure. This endpoint is idempotent and retry-safe.
`,
    requestFormat: "json",
    parameters: [
      {
        name: "body",
        type: "Body",
        schema: DepositWebhookInput,
      },
      {
        name: "Idempotency-Key",
        type: "Header",
        schema: z
          .string()
          .min(8)
          .max(255)
          .describe(
            "A unique key generated by the client to guarantee idempotent requests. The same key must be reused for retries of the same logical operation. Scope: per authenticated user + endpoint."
          ),
      },
    ],
    response: z.object({ ok: z.boolean() }).partial().passthrough(),
    errors: [
      {
        status: 400,
        description: `Invalid payload`,
        schema: ErrorResponse,
      },
      {
        status: 500,
        description: `Webhook processing failed`,
        schema: ErrorResponse,
      },
    ],
  },
  {
    method: "post",
    path: "/webhooks/withdraw",
    alias: "postWebhookswithdraw",
    description: `Webhook endpoint called by the bank / off-ramp provider to notify Kizo about withdrawal success or failure. On success, locked funds are released. On failure, locked funds are refunded. This endpoint is idempotent and retry-safe.
`,
    requestFormat: "json",
    parameters: [
      {
        name: "body",
        type: "Body",
        schema: WithdrawWebhookInput,
      },
      {
        name: "Idempotency-Key",
        type: "Header",
        schema: z
          .string()
          .min(8)
          .max(255)
          .describe(
            "A unique key generated by the client to guarantee idempotent requests. The same key must be reused for retries of the same logical operation. Scope: per authenticated user + endpoint."
          ),
      },
    ],
    response: z.object({ ok: z.boolean() }).partial().passthrough(),
    errors: [
      {
        status: 400,
        description: `Invalid payload`,
        schema: ErrorResponse,
      },
      {
        status: 500,
        description: `Webhook processing failed`,
        schema: ErrorResponse,
      },
    ],
  },
]);

export const api = new Zodios(endpoints);

export function createApiClient(baseUrl: string, options?: ZodiosOptions) {
  return new Zodios(baseUrl, endpoints, options);
}
