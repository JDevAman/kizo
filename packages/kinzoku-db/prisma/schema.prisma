generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// --- ENUMS ---
enum Role {
  USER
  ADMIN
  SUPERADMIN
}

enum UserStatus {
  ACTIVE
  SUSPENDED
  BANNED
  PENDING_KYC
}

enum AuthProvider {
  EMAIL
  GOOGLE
  GITHUB
}

enum TxStatus {
  PROCESSING
  SUCCESS
  FAILED
}

enum RequestStatus {
  PENDING
  ACCEPTED
  REJECTED
  EXPIRED
}

enum TxType {
  P2P_TRANSFER  // User to User
  DEPOSIT       // OnRamp
  WITHDRAWAL    // OffRamp
}

// --- MODELS ---

model User {
  id            String       @id @default(uuid())
  userName      String       @unique // This is the Email
  firstName     String
  lastName      String
  password      String?      // Nullable for OAuth
  avatar        String?
  role          Role         @default(USER)
  status        UserStatus   @default(ACTIVE) // ✅ RBAC: Control access
  
  // Relations
  Account       Account?
  RefreshTokens RefreshToken[]
  
  // Ledger Relations
  SentTx        Transaction[] @relation("SentTx")
  ReceivedTx    Transaction[] @relation("ReceivedTx")
  
  // Request Relations
  SentRequests      PaymentRequest[] @relation("Requester")
  ReceivedRequests  PaymentRequest[] @relation("Payer")

  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt

  @@map("users") // Good practice: lowercase table names in Postgres
}

// ✅ AUTH: Database-backed sessions for security
model RefreshToken {
  id        String   @id @default(uuid())
  token     String   @unique
  userId    String
  expiresAt DateTime
  revoked   Boolean  @default(false)
  createdAt DateTime @default(now())

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("refresh_tokens")
}

model Account {
  id        String   @id @default(uuid())
  userId    String   @unique
  balance   Int      @default(0) // Cents/Paisa. Warning: Postgres Int max is ~2B. Use BigInt if expecting > 20M.
  locked    Int      @default(0) // ✅ IMPORTANT: Locks balance during processing to prevent double-spend
  
  version   Int      @default(0) // ✅ Optimistic Locking for high-concurrency (Critical for Java migration later)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user      User     @relation(fields: [userId], references: [id])

  @@map("accounts")
}

// ✅ LEDGER: Only actual money movement lives here
model Transaction {
  id          String    @id @default(uuid())
  amount      Int
  status      TxStatus  @default(PROCESSING)
  type        TxType
  referenceId String    @unique @default(uuid()) // Public ID for support tickets
  
  // Relations
  fromUserId  String?   // Null for DEPOSIT
  fromUser    User?     @relation("SentTx", fields: [fromUserId], references: [id])
  
  toUserId    String    // Null for WITHDRAWAL (if internal wallet burns money), usually required though
  toUser      User?     @relation("ReceivedTx", fields: [toUserId], references: [id])

  // Link to a Request (Optional: Did this transaction come from a request?)
  requestId   String?   @unique
  request     PaymentRequest? @relation(fields: [requestId], references: [id])

  createdAt   DateTime  @default(now())
  
  @@index([fromUserId])
  @@index([toUserId])
  @@map("transactions")
}

// ✅ REQUESTS: Social layer (Intent to pay)
model PaymentRequest {
  id          String        @id @default(uuid())
  amount      Int
  status      RequestStatus @default(PENDING)
  note        String?

  requesterId String        // Who is asking for money
  requester   User          @relation("Requester", fields: [requesterId], references: [id])

  payerId     String        // Who needs to pay
  payer       User          @relation("Payer", fields: [payerId], references: [id])

  // If accepted, a transaction is created
  transaction Transaction?

  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  @@index([requesterId])
  @@index([payerId])
  @@map("payment_requests")
}